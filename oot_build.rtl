/*******************************************************
 * <z64.me> zzrtl script for injecting assets into OoT *
 *******************************************************/

/* how to use */
/* uncomment the enum associated with the OoT version you *
 * are targeting, and comment out or delete the others    */

/* global variables */
char *g_tsv;
	
	/* OoT debug */
enum {
	TBL_OBJECT              		 = 0x00B9E6C8  // object table
	, TBL_OBJECT_ENTRIES 		     = 402         // object count
	, TBL_ACTOR        		         = 0x00B8D440  // actor overlay table
	, TBL_ACTOR_ENTRIES    		     = 471         // actor overlay count
	, TBL_PARTICLE          		 = 0x00B8CB50  // particle overlay table
	, TBL_PARTICLE_ENTRIES 		     = 37          // particle overlay count
	, TBL_SCENE            		     = 0x00BA0BB0  // scene table
	, TBL_SCENE_ENTRIES    		     = 110         // scene count
	, TBL_ROUTE             		 = 0x00B9F360  // route table
	, TBL_ROUTE_ENTRIES     		 = 1556        // route count
	, TBL_AUDIOBANK 				 = 0x00BCC270  //audiobanktable
	, TBL_AUDIOBANK_FILE 			 = 0x00019030  //audiobank file
	, TBL_AUDIOBANK_SIZE			 = 0x0002BDC0  //audiobank file-size
	, TBL_SEQUENCEINSTRUMENTSET		 = 0x00BCC4E0  // instrument set table
	, TBL_SEQUENCE_FILE 		     = 0x00044DF0  // sequence file offset
	, TBL_SEQUENCE_POINTER 		     = 0x00BCC6A0  // sequence pointer table
	, TBL_ENTRANCECUTSCENE 		     = 0x00B95394  // entrancecutscene table
	, TBL_ENTRANCECUTSCENE_ENTRIES   = 34          // entrancecutscene count	
	, TBL_MESSAGE 					 = 0x00BC24C0  // offset for entrancecutscene table
	, TBL_MESSAGE_ENTRIES  		     = 2116        // entrancecutscene count
	, TBL_MESSAGE_DATA			     = 0x008C6000  //offset for english text
	, TBL_MESSAGE_TOOL      		 = 1		   //select tool 0 = "ocarina text editor" and 1 = "zelda's letter"	
	, TBL_RESTRICTIONFLAG   		 = 0x00B9CA10  //offset for restricitonflag table
	, TBL_RESTRICTIONFLAG_ENTRIES    = 100	       //restrictionflag count
	, TBL_DMA               		 = 0x00012F70  // dma table
	, TBL_DMA_ENTRIES       		 = 1548        // dma entries
	, TBL_OVL_GAMESTATE     		 = 0x00B969D0  // ovl_title
	, TBL_OVL_PLAYER        		 = 0x00BA4340  // ovl_kaleido_scope
	, TBL_OVL_MAPMARK      		     = 0x00B97298  // ovl_map_mark_data
	
	, TITLECARD_W          		     = 144         // title card dimensions
	, TITLECARD_H          		     = 24          // use 72 to include de, fr
	, VRAM_CODE              		 = 0x8001CE60  // vram start of code
	, VROM_CODE            		     = 0x00A94000  // vrom start of code
	, VROM_PLAYER          		     = 0x00C010B0  // vrom start of player_actor
	
	, DMA_ITEM_FIELD         		 = 9           // icon_item_field_static
	, DMA_ITEM_LOCALIZED    		 = 14          // last icon_item_x_static
	, DMA_CODE             		     = 28
	, DMA_OVL_TITLE
	, DMA_OVL_SELECT
	, DMA_OVL_OPENING
	, DMA_OVL_FILE_CHOOSE
	, DMA_OVL_KALEIDO_SCOPE
	, DMA_OVL_PLAYER_ACTOR
	, DMA_OVL_MAP_MARK_DATA
	
	, DMA_ACTOR_FIRST      		    = 36          // En_Test
	, DMA_ACTOR_LAST        	    = 497         // Shot_Sun
	, DMA_OBJECT_FIRST      		= 498         // gameplay_keep
	, DMA_OBJECT_LAST       		= 879         // object_zl4
	, DMA_G_PN_FIRST       		    = 880         // g_pn_01
	, DMA_G_PN_LAST         		= 936         // g_pn_57
	, DMA_SKYBOX_FIRST      		= 941         // vr_fine0_static
	, DMA_SKYBOX_LAST       		= 960         // vr_holy1_pal_static
	, DMA_PRERENDER_FIRST   		= 961         // vr_MDVR_static
	, DMA_PRERENDER_LAST   		    = 1004        // vr_FCVR_pal_static
	, DMA_SCENE_FIRST       		= 1007        // syotes_scene
	, DMA_SCENE_LAST       		    = 1517        // test01_room_0
	, DMA_UNUSED_FIRST      		= 1518        // bump_texture_static
	, DMA_UNUSED_LAST      		    = 1530        // anime_texture_6_static
	, DMA_SOFTSPRITE        		= 1531        // softsprite_matrix_static
	, DMA_BLANK_FIRST       		= 1532        // first blank dma entry
	, DMA_BLANK_LAST        		= 1547        // last blank dma entry
	
	, ACTID_LINK         		    = 0           // link's actor id
	
	// hard-coded function pointers for ovl_player_actor
	, OFS_OVL_PLAYER_ACTOR_INIT_HI  = 0x00B288F8  // init
	, OFS_OVL_PLAYER_ACTOR_INIT_LO  = 0x00B28900
	, OFS_OVL_PLAYER_ACTOR_DEST_HI  = 0x00B28908  // dest
	, OFS_OVL_PLAYER_ACTOR_DEST_LO  = 0x00B28914
	, OFS_OVL_PLAYER_ACTOR_MAIN_HI  = 0x00B2891C  // main (update)
	, OFS_OVL_PLAYER_ACTOR_MAIN_LO  = 0x00B28928
	, OFS_OVL_PLAYER_ACTOR_DRAW_HI  = 0x00B28930  // draw
	, OFS_OVL_PLAYER_ACTOR_DRAW_LO  = 0x00B2893C
	
	// hard-coded function pointers for ovl_kaleido_scope
	, OFS_OVL_KALEIDO_SCOPE_INIT_HI = 0x00B33208  // init
	, OFS_OVL_KALEIDO_SCOPE_INIT_LO = 0x00B3320C
	, OFS_OVL_KALEIDO_SCOPE_DRAW_HI = 0x00B33218  // draw
	, OFS_OVL_KALEIDO_SCOPE_DRAW_LO = 0x00B33220
};

/* OoT NTSC 1.0
enum {
	TBL_OBJECT               = 0x00B6EF58  // object table
	, TBL_OBJECT_ENTRIES     = 402         // object count
	, TBL_ACTOR              = 0x00B5E490  // actor overlay table
	, TBL_ACTOR_ENTRIES      = 471         // actor overlay count
	, TBL_PARTICLE           = 0x00B5DBA0  // particle overlay table
	, TBL_PARTICLE_ENTRIES   = 37          // particle overlay count
	, TBL_SCENE              = 0x00B71440  // scene table
	, TBL_SCENE_ENTRIES      = 101         // scene count
	, TBL_ROUTE              = 0x00B6FBF0  // route table
	, TBL_ROUTE_ENTRIES      = 1556        // route count
	, TBL_DMA                = 0x00007430  // dma table
	, TBL_DMA_ENTRIES        = 1526        // dma entries
	, TBL_OVL_GAMESTATE      = 0x00B672A0  // game state overlay table
	, TBL_OVL_PLAYER         = 0x00B743E0  // pause/player ovl table
	, TBL_OVL_MAPMARK        = 0x00B67B58  // map_mark_data ovl table
	
	, TITLECARD_W            = 144         // title card dimensions
	, TITLECARD_H            = 48          // use 24 for jp only
	, VRAM_CODE              = 0x800110A0  // vram start of code
	, VROM_CODE              = 0x00A87000  // vrom start of code
	, VROM_PLAYER            = 0x00BCDB70  // vrom start of player_actor
	
	, DMA_ITEM_FIELD         = 10          // icon_item_field_static
	, DMA_ITEM_LOCALIZED     = 14          // last icon_item_x_static
	, DMA_CODE               = 27
	, DMA_OVL_TITLE          = 29
	, DMA_OVL_SELECT
	, DMA_OVL_OPENING
	, DMA_OVL_FILE_CHOOSE
	, DMA_OVL_KALEIDO_SCOPE
	, DMA_OVL_PLAYER_ACTOR
	, DMA_OVL_MAP_MARK_DATA
	
	, DMA_ACTOR_FIRST        = 36          // En_Test
	, DMA_ACTOR_LAST         = 497         // Shot_Sun
	, DMA_OBJECT_FIRST       = 498         // gameplay_keep
	, DMA_OBJECT_LAST        = 879         // object_zl4
	, DMA_G_PN_FIRST         = 880         // g_pn_01
	, DMA_G_PN_LAST          = 936         // g_pn_57
	, DMA_SKYBOX_FIRST       = 941         // vr_fine0_static
	, DMA_SKYBOX_LAST        = 960         // vr_holy1_pal_static
	, DMA_PRERENDER_FIRST    = 961         // vr_MDVR_static
	, DMA_PRERENDER_LAST     = 1004        // vr_FCVR_pal_static
	, DMA_SCENE_FIRST        = 1007        // ddan_scene
	, DMA_SCENE_LAST         = 1495        // ganontikasonogo_room_1
	, DMA_UNUSED_FIRST       = 1496        // bump_texture_static
	, DMA_UNUSED_LAST        = 1508        // anime_texture_6_static
	, DMA_SOFTSPRITE         = 1509        // softsprite_matrix_static
	, DMA_BLANK_FIRST        = 1510        // first blank dma entry
	, DMA_BLANK_LAST         = 1525        // last blank dma entry
	
	, ACTID_LINK             = 0           // link's actor id
	
	// hard-coded function pointers for ovl_player_actor
	, OFS_OVL_PLAYER_ACTOR_INIT_HI  = 0x00B0D5B8  // init
	, OFS_OVL_PLAYER_ACTOR_INIT_LO  = 0x00B0D5C0
	, OFS_OVL_PLAYER_ACTOR_DEST_HI  = 0x00B0D5C8  // dest
	, OFS_OVL_PLAYER_ACTOR_DEST_LO  = 0x00B0D5D4
	, OFS_OVL_PLAYER_ACTOR_MAIN_HI  = 0x00B0D5DC  // main (update)
	, OFS_OVL_PLAYER_ACTOR_MAIN_LO  = 0x00B0D5E8
	, OFS_OVL_PLAYER_ACTOR_DRAW_HI  = 0x00B0D5F0  // draw
	, OFS_OVL_PLAYER_ACTOR_DRAW_LO  = 0x00B0D5FC
	
	// hard-coded function pointers for ovl_kaleido_scope
	, OFS_OVL_KALEIDO_SCOPE_INIT_HI = 0x00B0FE48  // init
	, OFS_OVL_KALEIDO_SCOPE_INIT_LO = 0x00B0FE50
	, OFS_OVL_KALEIDO_SCOPE_DRAW_HI = 0x00B0FE58  // draw
	, OFS_OVL_KALEIDO_SCOPE_DRAW_LO = 0x00B0FE64
}; */

/* valid (fmt, bpp) options for png functions */
enum n64texconv_fmt
{
	N64TEXCONV_RGBA = 0
	, N64TEXCONV_YUV
	, N64TEXCONV_CI
	, N64TEXCONV_IA
	, N64TEXCONV_I
};
enum n64texconv_bpp
{
	N64TEXCONV_4 = 0
	, N64TEXCONV_8
	, N64TEXCONV_16
	, N64TEXCONV_32
};

enum bool
{
	false = 0
	, true = 1
	, compress = 1
};

/* helper function that zeroes out skipped table entries */
void
skip_test(struct rom *rom, int index, int *last, int table, int stride)
{
	/* skipped one or more entries between invocations */
	if (index > *last + 1)
	{
		/* advance to first skipped entry */
		*last = *last + 1;
		
		/* zero out skipped entries */
		memset(
			rom.raw(table + *last * stride)
			, 0
			, (index - *last) * stride
		);
	}
	
	/* update last known index */
	*last = index;
}

/* helper function that writes lui, addiu pair into rom; hi and lo
   must be rom offsets of lui and addiu opcodes, respectively */
void
split_ptr(struct rom *rom, int ptr, int hi, int lo, int correct)
{
	int v;
	int tell;

	/* back up rom address */
	tell = rom.tell();

	/* update hi part of pointer */
	rom.seek(hi + 2);
	v = u16(ptr >> 16);
	if (correct && (u16(ptr) & 0x8000))
		v++;
	rom.write16(v);

	/* update low part of pointer */
	rom.seek(lo + 2);
	rom.write16(ptr);

	/* restore rom address */
	rom.seek(tell);
}

void
system_overlay(struct rom *rom)
{
	struct conf *conf;
	char *filename;
	char *ovl;
	FILE *fp;
	int  *entry;
	int  *Oarr;
	int  *arr;
	int   vram;
	int   vram_sz;
	int   ptr;
	int   i;
	
	dir_enter("overlay");
	
	/* system overlays aligned 0x10 in retail */
	rom.align(0x10);
	
	/* overlay filenames */
	filename =
		"ovl_title\0"          /* n64 logo animation       */
		"ovl_select\0"         /* map select               */
		"ovl_opening\0"        /* initialized title screen */
		"ovl_file_choose\0"    /* file select screen       */
		"ovl_kaleido_scope\0"  /* pause screen             */
		"ovl_player_actor\0"   /* link's actor             */
		"ovl_map_mark_data\0"  /* minimap icon data        */
	;
	
	/* create a list of offsets to individual overlay table entries */
	entry = int_array(
		7                                // num elements
		, TBL_OVL_GAMESTATE + 2 * 48     // ovl_title
		, TBL_OVL_GAMESTATE + 1 * 48     // ovl_select
		, TBL_OVL_GAMESTATE + 4 * 48     // ovl_opening
		, TBL_OVL_GAMESTATE + 5 * 48     // ovl_file_choose
		, TBL_OVL_PLAYER    + 0 * 28     // ovl_kaleido_scope
		, TBL_OVL_PLAYER    + 1 * 28     // ovl_player_actor
		, TBL_OVL_MAPMARK                // ovl_map_mark_data
	);
	
	/* create array of offsets to hard-coded split function pointers */
	Oarr = int_array(
	   19                               // num elements
	   
	   // these all contain none
		, 0                              // ovl_title
		, 0                              // ovl_select
		, 0                              // ovl_opening
		, 0                              // ovl_file_choose
		
		, OFS_OVL_KALEIDO_SCOPE_INIT_HI  // ovl_kaleido_scope
		, OFS_OVL_KALEIDO_SCOPE_INIT_LO
		, OFS_OVL_KALEIDO_SCOPE_DRAW_HI
		, OFS_OVL_KALEIDO_SCOPE_DRAW_LO
		, 0
		
		, OFS_OVL_PLAYER_ACTOR_INIT_HI   // ovl_player_actor
		, OFS_OVL_PLAYER_ACTOR_INIT_LO
		, OFS_OVL_PLAYER_ACTOR_DEST_HI
		, OFS_OVL_PLAYER_ACTOR_DEST_LO
		, OFS_OVL_PLAYER_ACTOR_MAIN_HI
		, OFS_OVL_PLAYER_ACTOR_MAIN_LO
		, OFS_OVL_PLAYER_ACTOR_DRAW_HI
		, OFS_OVL_PLAYER_ACTOR_DRAW_LO
		, 0
		
		, 0                              // ovl_map_mark_data
	);
	
	i = 0;
	arr = Oarr;
	while (i < 7)
	{
		/* enter overlay name directory */
		dir_enter(substring(filename, i));
		
		/* go to table entry (skip first word) */
		rom.seek(entry[i] + 4);
		
		/* inject file */
		ovl = rom.inject("*.zovl", compress);
		
		/* get overlay vram size */
		vram_sz = ovl_vram_sz(ovl, rom.file_sz());
		
		/* parse configuration file */
		conf = conf.new("conf.txt", "list");
		while (*arr)
		{
			/* function pointers in conf are in same order as array */
			ptr = conf.get_int(0);
			
			/* write split function pointer into rom */
			split_ptr(rom, ptr, arr[0], arr[1], true);
			
			/* advance to next item */
			arr = arr + 2;
			conf.next();
		}
		arr++; /* skip trailing 0 */
		
		rom.write32(rom.file_start());  /* vrom start  */
		rom.write32(rom.file_end());    /* vrom end    */
		if (conf.exists("vram"))        /* custom vram */
		{
			vram = conf.get_int("vram");
			rom.write32(vram);           /* vram start  */
		}
		else
			vram = rom.read32();         /* vram start  */
		rom.write32(vram + vram_sz);    /* vram end    */
		
		/* game state overlays */
		if (i < 4)
		{
			rom.seek_cur(4);
			rom.write32(conf.get_int("init"));
			rom.write32(conf.get_int("dest"));
			rom.seek_cur(12);
			rom.write32(conf.get_int("size"));
		}
		/* ovl_map_mark_data */
		else if (i == 6)
			rom.write32(conf.get_int("dungeon_mark_data"));
		
		/* advance to next */
		dir_leave();
		conf.free();
		i++;
	}
	
	/* cleanup */
	free(Oarr);
	dir_leave();
}

void
systemdir(struct rom *rom)
{
	dir_enter("system");
	system_overlay(rom);
	dir_leave();
}

void
seek_next_audio_struct(struct rom *rom)
{
	int test;

	rom.seek_cur(32);
	test = 0;
	while (test == 0)
	{
		//printf("\n%X", rom.tell());
		rom.seek_cur(16);
		
		rom.seek_cur(12);
		/*checks if the next line is an envelope*/
		if (rom.read16() == 0xFFFF)
		{
			if (rom.read16() == 0x0000)
			{
				test = 1;
			}
			rom.seek_cur(-2);
		}
		rom.seek_cur(2);
		/*checks if next line is a new structure*/
		if (rom.read32() == 0x02)
		{
			if (rom.read32() == 0x02)
			{
				test = 1;
			}
			rom.seek_cur(-4);
		}
		rom.seek_cur(-4);
	}
	rom.seek_cur(-16);
//printf("\n%X", rom.tell());
}

int
comparedatachunk(struct rom *rom, FILE *file, int bankpointer, int filestart)
{
	int *data;
	int sz;
	int var;
	int test;
	int test2;

	rom.seek(bankpointer);
	data = loadfile(file, &sz, 0);
	

	while (test2 = 0)
	{

		var = filestart;
		test =0;
		while (test = 0)
		{
			if (rom.read8() != data[var])
				{
					test = 1;
				}
			var = var++;
			if (var > sz)
				{
					test = 1;
					test2 = rom.tell();
				}
			else
			{
				if (get32(&data[var/4]+4) == 0x2 && get32(&data[var/4+5]) == 0x2)
				{
					test = 1;
					test2 = rom.tell();
				}
			}


		}		
		seek_next_audio_struct(rom);
		
		rom.seek_cur(12);
		/*checks if the next line is an envelope*/
		if (rom.read16() == 0xFFFF)
		{
			if (rom.read16() == 0x0000)
			{
				test2 = rom.tell()-16;
			}
			rom.seek_cur(-2);
		}
		rom.seek_cur(-14);
	}
	free(data);
	return test2;


}

void
audiobank(struct rom *rom)
{	
	struct folder *list;
	struct folder *list2;
	struct conf *table;
	FILE *fp;
	FILE *fp2;
	FILE *fp3;
	int instrumentpointer;
	int bankpointer;
	int drumstructureindex;
	int *data;
	int sz;
	int var;
	int var2;
	int var3;
	int name;

	/*allocate memory for name*/
	name = malloc(256);

	/*set bankpointer for later (this skips first 3 system-related banks*/
	bankpointer = TBL_AUDIOBANK_FILE + 0x5F30;

	/*enter audio and bank folders*/
	dir_enter("audio");
	dir_enter("banks");

	/*creates a list of the folders and skips past the first 3 unsupported ones*/
	list = list.new(0);
	while (list.index() < 3)
	{
		list.next();
	}

	/*load data from filename*/
	while (list.remaining())   
	{
		/*display progress*/	
		printf("\rworking on AUDIO BANKS %d/%d:", list.index(), 36);

		/*enter the bank folder and open the list of instrument folders*/
		dir_enter(list.name());
		list2 = list2.new(0);
	
		/*set the instrument pointer to bottom of instrument array*/
		instrumentpointer = (8 + (list2.max()+1) * 4)/16*16 + 16;
		instrumentpointer = instrumentpointer + 16;

		/*clean the bank header aka write it full of zeros*/
		rom.seek(bankpointer);
		var = 0;
		while (var < instrumentpointer/4)
		{
			rom.write32(0);
			var++;
		}

		/*goes through all the instruments*/
		while (list2.remaining())
		{
			/*open the folder for the instrument*/
			dir_enter(list2.name());
			
			/*write pointer into header of file*/
			rom.seek(bankpointer + 8 + list2.index()*4);
			rom.write32(instrumentpointer);
			
			/*seek to the position of the writing in the bank*/
			rom.seek(bankpointer + instrumentpointer);
			
			/*open the config file and write the begining of the instrument index*/
			table = loadfile("config.tsv",0,0);
			sscanf(tsv_col_row(table,"split1",1), "%d", &var);
			rom.write8(var);
			sscanf(tsv_col_row(table,"split2",1), "%d", &var);
			rom.write8(var);
			sscanf(tsv_col_row(table,"split3",1), "%d", &var);
			rom.write8(var);
			sscanf(tsv_col_row(table,"release",1), "%d", &var);
			rom.write8(var);
			rom.write32(instrumentpointer+0x20);

			/*write the envelope*/
			rom.seek_cur(24);
			sscanf(tsv_col_row(table,"atkrate",1), "%d", &var);
			rom.write16(var);
			sscanf(tsv_col_row(table,"atklvl",1), "%d", &var);
			rom.write16(var);
			sscanf(tsv_col_row(table,"dcy1rt",1), "%d", &var);
			rom.write16(var);
			sscanf(tsv_col_row(table,"dcy1lvl",1), "%d", &var);
			rom.write16(var);
			sscanf(tsv_col_row(table,"dcy2rt",1), "%d", &var);
			rom.write16(var);
			sscanf(tsv_col_row(table,"dcy2lvl",1), "%d", &var);
			rom.write16(var);
			rom.write16(0xFFFF);
			rom.write16(0);

			/*sets var2 to point to the first data structure*/
			var2 = instrumentpointer + 0x30;

			/*check if first data structure exists*/
			if (file_exists("data_1"))
			{
				/*seek to the pointer in the instrument index and write the offset for the structure*/
				rom.seek(bankpointer + instrumentpointer + 8);
				rom.write32(var2);

				/*read and write the pitch from the table(i used a two tier table so the column name is weird)*/
				sscanf(tsv_col_row(table,"split2",3), "%X", &var);
				rom.write32(var);

				/*returns to the sturcture offset and writes the structure*/
				rom.seek(bankpointer + var2);
				data = loadfile("data_1", &sz, 0);
				rom.write(data, sz);

				/*updates offsets in the header to point to the sample offset and the two data structure offsets.*/
				rom.seek(bankpointer + var2 + 4);
				sscanf(tsv_col_row(table,"split1",3), "%X", &var);
				rom.write32(var);
				rom.write32(var2 + 96);
				rom.write32(var2 + 16);

				/*moves pointer variable forward and frees the file*/
				var2 = var2 + sz;
				free(data);
			}
			else
			{ 
				/*if there's no data-structure it writes in zeros.*/
				rom.seek(bankpointer + instrumentpointer + 8);
				rom.write32(0);
				rom.write32(0);
			}
			/*rinse and repeat (refer to above structure's notes)*/
			if (file_exists("data_2"))
			{
				rom.seek(bankpointer + instrumentpointer + 16);
				rom.write32(var2);
				sscanf(tsv_col_row(table,"atkrate",3), "%X", &var);
				rom.write32(var);
				rom.seek(bankpointer + var2);
				data = loadfile("data_2", &sz, 0);
				rom.write(data, sz);
				rom.seek(bankpointer + var2 + 4);
				sscanf(tsv_col_row(table,"release",3), "%X", &var);
				rom.write32(var);
				rom.write32(var2 + 96);
				rom.write32(var2 + 16);
				var2 = var2 + sz;
				free(data);
			}
			else
			{  
				rom.seek(bankpointer + instrumentpointer + 16);
				rom.write32(0);
				rom.write32(0);
			}

			/*rinse and repeat (refer to data_1's notes)*/
			if (file_exists("data_3"))
			{
				rom.seek(bankpointer + instrumentpointer + 24);
				rom.write32(var2);
				sscanf(tsv_col_row(table,"dcy1lvl",3), "%X", &var);
				rom.write32(var);
				rom.seek(bankpointer + var2);
				data = loadfile("data_3", &sz, 0);
				rom.write(data, sz);
				rom.seek(bankpointer + var2 + 4);
				sscanf(tsv_col_row(table,"dcy1rt",3), "%X", &var);
				rom.write32(var);
				rom.write32(var2 + 96);
				rom.write32(var2 + 16);
				var2 = var2 + sz;
				free(data);
			}
			else
			{  
				rom.seek(bankpointer + instrumentpointer + 24);
				rom.write32(0);
				rom.write32(0);
			}

			/*moves pointer forward */
			instrumentpointer = var2;
					
			/*leave instrument folder and move to next file*/
			dir_leave();
			list2.next();
		}

		/*seeks to current spot in the rom*/
		rom.seek(bankpointer + instrumentpointer);

		/*check if there are drums to add*/
		if (dir_exists("_drums"))
		{
			/*enters the directory and loads the drum file*/
			dir_enter("_drums");
			data = loadfile("drums", &sz,0);
			table = loadfile("config.tsv",0,0);

			/*find envelope pointer aka end of drum indexes and sets var2 to it*/
			var2 = 0;
			while ( (get32(&data[var2]+8) >= 0x1 && get32(&data[var2]+8) <= 0x4 && get32(&data[var2]+9) >= 0x1 && get32(&data[var2]+9) <= 0x4) == 0)
			{
				var2 = var2 + 4;
			}

			/*writes all the drum indexes*/
			var = 0;
			while (var < var2)
			{
				rom.write32(get32(&data[var]));
				rom.write32(get32(&data[var+1])-get32(&data[1]) + instrumentpointer + var2*4 + 0x10);
				rom.write32(get32(&data[var+2]));
				rom.write32(instrumentpointer + var2*4);
				var = var + 4;
			}

			/*write the envelope*/
			sscanf(tsv_col_row(table,"atkrate",1), "%d", &var);
			rom.write16(var);
			sscanf(tsv_col_row(table,"atklvl",1), "%d", &var);
			rom.write16(var);
			sscanf(tsv_col_row(table,"dcy1rt",1), "%d", &var);
			rom.write16(var);
			sscanf(tsv_col_row(table,"dcy1lvl",1), "%d", &var);
			rom.write16(var);
			sscanf(tsv_col_row(table,"dcy2rt",1), "%d", &var);
			rom.write16(var);
			sscanf(tsv_col_row(table,"dcy2lvl",1), "%d", &var);
			rom.write16(var);
			rom.write16(0xFFFF);
			rom.write16(0);

			/*write all the drum chunks*/
			var = var2 + 4;
			drumstructureindex = 0;
			while (var < sz/4)
			{	
				/*copies the begining of the data's header*/
				rom.write32(get32(&data[var]));
				var++;

				/*writes the sample offset from the config file*/
				sscanf(tsv_col_row(table,"atklvl",3+ drumstructureindex), "%X", &var3);
				rom.write32(var3);
				var = var + 3;
				drumstructureindex++;

				/*figures out length of data by reading a variable and then writes appropriate offsets.*/
				if (get32(&data[var]+1) == 0x4)
				{
					rom.write32(instrumentpointer + var*4 + 144);
					rom.write32(instrumentpointer + var*4);
				}
				else
				{
					if (get32(&data[var]+1) == 0x4211)
					{
						rom.write32(instrumentpointer + var*4);
						rom.write32(instrumentpointer + var*4-0x120);
					}
					else
					{
						rom.write32(instrumentpointer + var*4 + 80);
						rom.write32(instrumentpointer + var*4);
					}
				}

				/*copies the rest of the data while checking for the next chunk. it looks for flags that it's the end of the structure.*/
				while (var < sz/4 && (!( get32(&data[var]+4) == 0x2 && get32(&data[var]+5) >= 0x1 && get32(&data[var]+5) <= 0x4) && !(get32(&data[var]+4) == 0x0 && get32(&data[var]+5) == 0x4211)))
				{
					rom.write32(get32(&data[var]));
					var++;	
				}
			}

			/*write pointer to array of drum pointers at begining of file*/
			rom.seek(bankpointer);
			rom.write32(instrumentpointer +  var*4 );
			rom.seek(bankpointer + instrumentpointer + var*4 );

			/*write the array of drum index pointers at end of file*/
			var = 0;
			while (var < var2)
			{
				rom.write32(instrumentpointer + var*4);
				var= var+4;
			}

			/*close the drum and config files and leaves the drum folder*/
			free(data);
			free(table);
			dir_leave();
		}

		/*warpsong bank is not supported rightnow, so we use the raw-bank dump to fix it.
		note: warpsong is functional to a degree. The ussue is that if the bank-size is too large 
		hyrule-field music wont continue playing after you cancel a warp. It could be fixed with better 
		memory management or if there is a way to allow for more memory when loading the bank.*/
		if (list.index() == 18)
		{
			rom.seek(bankpointer);
			data = loadfile(list.name(), &sz,1);
			rom.write(data, sz);
			free(data);
		}

		/*get the size of the bank*/
		instrumentpointer = rom.tell() - bankpointer;

		/*fix the audiobank table*/
		rom.seek(TBL_AUDIOBANK + 16 + list.index()*16);
		rom.write32(bankpointer-TBL_AUDIOBANK_FILE);
		rom.write32(instrumentpointer);
		rom.write8(2);
		rom.write8(2);
		rom.write8(1);
		rom.seek_cur(1);
		rom.write8((list2.max()+1));
		if (dir_exists("drums"))
			{
				rom.write8(0x40);
			}

		/*extract a bank build file, just for debugging*/
		sprintf(name, "%s_build", list.name());
		rom.extract(name, bankpointer,  bankpointer + instrumentpointer);
		list2.free();
		dir_leave();

		/*move forward to next audiobank and update the bank pointer*/
		bankpointer = bankpointer + instrumentpointer;
		list.next();
	}
	
	/*add the final bank with empty space to the bank table*/
	rom.seek(TBL_AUDIOBANK + 32 + list.max()*16);
	rom.write32(bankpointer-TBL_AUDIOBANK_FILE);
	rom.write32(TBL_AUDIOBANK_SIZE - bankpointer);
	rom.seek(bankpointer);

	/*checks if the bank-files excede the space available and sends an error*/
	if (bankpointer + 0x100 > TBL_AUDIOBANK_FILE + TBL_AUDIOBANK_SIZE)
	{
		printf("\n\n\nWARNING--- AUDIOBANK FILE IS TOO FULL\nWILL CAUSE AUDIO ERRORS\n\n");
	}

	/*load in and write that last bank*/
	data = loadfile(".do_not_delete", 0, 0);
	var = 0;
	while (var<40)
	{
		rom.write32(get32(&data[var]));
		var++;
	}

	/*leave the bank and audio folders*/
	dir_leave();
	dir_leave();

	/*make new line for next console message*/
	printf("\n");
}

void
audioseq(struct rom *rom)
{	
	struct folder *list;
	struct conf *table;
	FILE *fp;
	int sequencepointer;
	int index;
	int bankid;
	int sequencebank;
	int sequenceinstrumentpointer;
	int numberofsequences;
	int var;
	char *data;
	int sz;
	int name;
	int name2;

	/*message console*/
	printf("working on AUDIO SEQUENCES...\n");

	/*allocate memory for name*/
	name = malloc(256);
	name2 = malloc(256);

	/*set sequencpointer for later*/
	sequencepointer = TBL_SEQUENCE_FILE;

	/*enter audio and sequences folder*/
	dir_enter("audio");
	dir_enter("sequences");

	/*open a list of .bin files in the sequences folder*/
	list = list.new(".bin");

	/*write each file to the rom*/
	while (list.remaining())
	{
		/*get the file name and load it*/
		name = list.name();
		index = list.index();
		data = loadfile(name,&sz, 0);
	
		/*seek to and write sequence table*/
		rom.seek(TBL_SEQUENCE_POINTER + 16 + list.index()*16);
		rom.write32(sequencepointer - TBL_SEQUENCE_FILE); //write start
		rom.write32(sz); //write length

		/*seek to and write sequence data*/
		rom.seek(sequencepointer);
		rom.write(data, sz);
		
		/*advance sequence pointer and free the data*/
		sequencepointer = sequencepointer + sz;
		free(data);

		/*this is a fix for the file-select/fairyfountain issue, it writes its abnormal info into the sequence table*/
		if (list.index() + 1 == 87)
		{
			list.next();
			rom.seek(TBL_SEQUENCE_POINTER + 16 + list.index()*16);
			rom.write32(40);//write start
			rom.write32(0); //write length
		}

		/*load name for next cycle*/
		list.next();
	
	}

	free(data);
	/*leave the audiobanks folder*/
	dir_leave();

	/*write sequence number at start of sequence table*/
	rom.seek(TBL_SEQUENCE_POINTER);
	rom.write16(index);

	/*open the table and setup for writing*/
	table = loadfile("sequencetable.tsv", 0, false);
	numberofsequences = list.max()+1;
	sequenceinstrumentpointer = numberofsequences * 2 + 4;
	index = 1;

	/*write the sequence's audiobank into the file*/
	while (index < numberofsequences)
	{
		sscanf(tsv_col_row(table,"bank",index + 1), "%X", &sequencebank);
		rom.seek(TBL_SEQUENCEINSTRUMENTSET + sequenceinstrumentpointer);
		rom.write8(sequencebank);
		sequenceinstrumentpointer = sequenceinstrumentpointer+2;
		index++;
	}

	/*leave the audio folder and free the list*/
	dir_leave();
	list.free();
}


void
route(struct rom *rom)
{
	struct conf *table;
	char *music;
	char *card;
	int index_last;
	int fadeout;
	int fadein;
	int index;
	int scene;
	int spawn;
	int var;

	/*message console*/
	printf("building ROUTING TABLE...\n");

	/*enter folder*/
	dir_enter("scene");
	
	/* load the table */
	table = loadfile("route.tsv", 0, false);
	index_last = -1;
	index = 0;
	/* parse every row */
	while (index < TBL_ROUTE_ENTRIES)
	{
		/* retrieve variables */
		sscanf(tsv_col_row(table,"scene",index + 1), "%x", &scene);
		sscanf(tsv_col_row(table,"spawn",index + 1), "%d", &spawn);
		music  = tsv_col_row(table,"music",index + 1);
		card   =tsv_col_row(table,"title",index + 1);
		sscanf(tsv_col_row(table,"fadein",index + 1), "%d", &fadein);
		sscanf(tsv_col_row(table,"fadeout",index + 1), "%d", &fadeout);
				
		/* ensure we don't exceed table limit */
		if (index >= TBL_ROUTE_ENTRIES)
			die("route table limit exceeded");
		
		/* construct var */
		var = fadeout & 0x007F;
		var = var | (fadein & 0x007F) << 7;
		
		/* music flags */
		if (!strcasecmp(music, "go"))
			var = var | 0x8000;
		else if (strcasecmp(music, "stop"))
			die("unknown music flag '%s'", music);
		
		/* title card flags */
		if (!strcasecmp(card, "on"))
			var = var | 0x4000;
		else if (strcasecmp(card, "off"))
			die("unknown title card flag '%s'", card);
		
		/* zero out any skipped entries */
		skip_test(rom, index, &index_last, TBL_ROUTE, 4);
		
		/* go to table entry */
		rom.seek(TBL_ROUTE + index * 4);
		
		/* write table entry */
		rom.write8(scene);
		rom.write8(spawn);
		rom.write16(var);
		
		/* go to next row */
		index++;
	}
	
	/*leave folder*/
	dir_leave();
}

void
entrancecutscene(struct rom *rom)
{
	struct conf *table;
	int index;
	int index_last;
	int entrance;
	int age;
	int *agestr;
	int *tempstr;
	int flag;
	int offset;
	
	/*message console*/
	printf("building ENTRANCE CUTSCENE TABLE...\n");

	/*enter folder*/
	dir_enter("scene");

	/*set up the age array for reading later*/
	agestr = int_array(3, "child", "adult", "both");
		
	/* load the table */
	table =  loadfile("entrancecutscene.tsv", 0, false);
	index = 0;
	index_last = 0;

	/* parse every row */
	while (index < TBL_ENTRANCECUTSCENE_ENTRIES)
	{
		/* retrieve variables */
		sscanf(tsv_col_row(table,"entry",index + 1), "%X", &entrance);
		tempstr  = tsv_col_row(table,"age",index + 1);
		sscanf(tsv_col_row(table,"flag",index + 1), "%X", &flag);
		sscanf(tsv_col_row(table,"offset",index + 1), "%X", &offset);

		/* check the age string to set age variable*/
		age = 0;
		while(strcasecmp(agestr[age], tempstr) != 0)
		{	
			age = age + 1;
			if (age >= 3)
				die("error in cutsceneflag.txt check the spelling in age column");
		}	
		
		/* ensure we don't exceed table limit */
		if (index >= TBL_ENTRANCECUTSCENE_ENTRIES)
			die("ENTRANCECUTSCENE table limit exceeded");
		
		/* zero out any skipped entries */
		skip_test(rom, index, &index_last, TBL_ENTRANCECUTSCENE, 8);
		
		/* go to table entry */
		rom.seek(TBL_ENTRANCECUTSCENE + index * 8);
		
		/* write table entry */
		rom.write16(entrance);
		rom.write8(age);
		rom.write8(flag);
		rom.write32(offset);
		
		/* go to next row */
		index++;
	}
	
	/* cleanup */
	dir_leave();
}

void
restrictionflag(struct rom *rom)
{
	struct conf *table;
	int index_last;
	int index;
	int variable;
	int sceneid;
	int xx;
	int yy;
	int zz;	

	/*message the console*/
	printf("building RESTRICTIONFLAG TABLE...\n");

	/* enter directory and load the table */
	dir_enter("scene");

	/*load the table*/
	table = loadfile("restrictionflag.tsv", 0, false);
	index = 0;
	index_last = -1;
	
	while (index < TBL_RESTRICTIONFLAG_ENTRIES)
	{
		/*set the vars to zero*/
		xx = 0;
		yy =0;
		zz= 0;

		/* reads the table, tests the string and sets the variables using bitwise operations for the flag */
		sscanf(tsv_col_row(table,"scene",index + 1), "%X", &sceneid);
		if (strcasecmp(tsv_col_row(table,"bottle", index + 1),"off")) {xx = xx + (1 << 0);}
		if (strcasecmp(tsv_col_row(table,"abutton", index + 1),"off")) {xx = xx + (1 << 2);}
		if (strcasecmp(tsv_col_row(table,"bbutton", index + 1),"off")) {xx = xx + (1 << 4);}
		if (strcasecmp(tsv_col_row(table,"health", index + 1),"off")) {xx = xx + (1 << 6);}
		if (strcasecmp(tsv_col_row(table,"warpson", index + 1),"off")) {yy = yy + (1 << 0);}
		if (strcasecmp(tsv_col_row(table,"ocarina", index + 1),"off")) {yy = yy + (1 << 2);}
		if (strcasecmp(tsv_col_row(table,"hooksht", index + 1),"off")) {yy = yy + (1 << 4);}
		if (strcasecmp(tsv_col_row(table,"tradeit", index + 1),"off")) {yy = yy + (1 << 6);}
		if (strcasecmp(tsv_col_row(table,"global", index + 1),"off")) {zz = zz + (1 << 0);}
		if (strcasecmp(tsv_col_row(table,"dinnayr", index + 1),"off")) {zz = zz + (1 << 2);}
		if (strcasecmp(tsv_col_row(table,"farore", index + 1),"off")) {zz = zz + (1 << 4);}
		if (strcasecmp(tsv_col_row(table,"sunsong", index + 1),"off")) {zz = zz + (1 << 6);}
		
		/*if table is exceeded */
		if (index >= TBL_RESTRICTIONFLAG_ENTRIES)
			die("RESTRICTION table limit exceeded");
		
		/* zero out any skipped entries */
		skip_test(rom, index, &index_last, TBL_RESTRICTIONFLAG, 4);
	
		/* go to table entry */
		rom.seek(TBL_RESTRICTIONFLAG + index * 4);
		
		/* parse table entry */
		rom.write8(sceneid);
		rom.write8(xx);
		rom.write8(yy);
		rom.write8(zz);
		
		/* advance to next entry */
		index++;
	}
	 /*return to main directory*/	
	dir_leave();
}

void
message(struct rom *rom)
{
	int sz;
	char *data;
	int tablename;
 	int dataname;

 	/*set the filenames depending on which tool u are using*/
	if (TBL_MESSAGE_TOOL == 1)
	{
		tablename = "table.bin";
		dataname = "0_message_data_static.bin";
	}
	else
	{
		tablename = "MessageTable.tbl";
		dataname = "StringData.bin";
	}

	/*enter directory*/
	dir_enter("messages");

	/*load table from file*/
	data = loadfile(tablename,&sz, false);


	/*seek and write the table into the rom*/
	rom.seek(TBL_MESSAGE);
	rom.write(data, sz);

	/*load data from file*/
	data = loadfile(dataname,&sz, false);

	/*seek and write the data into the rom*/
	rom.seek(TBL_MESSAGE_DATA);
	rom.write(data, sz);

	/*leave the directory*/
	dir_leave();
}

/* process a single header, updating room command's contents */
/* returns non-zero if header or provided offset (ofs) is invalid */
int
scene_header_rooms(
	struct rom *rom
	, char *room_ptrs
	, int room_ct
	, int start
	, int sz
	, int ofs
)
{
	int rseg;
	char *b;
	char *b_end;
	
	/* entries pointing to 0 are valid, but not processed */
	if (!ofs)
		return 0;
	
	/* want only lower 3 bytes of ofs from this point on */
	rseg = ofs >> 24;
	ofs = ofs & 0xFFFFFF;
	
	/* invalid offset conditions */
	if (
		rseg != 0x02     /* invalid ram segment  */
		|| (ofs & 3)     /* unaligned pointer    */
		|| ofs + 8 > sz  /* pointer exceeds file */
	)
		return 1;
	
	b = rom.raw(start + ofs);
	b_end = rom.raw(start + sz);
	
	/* search scene header for room command (0x04) */
	while (b < b_end && *b != 0x04)
	{
		/* end loop conditions */
		if (
			*b == 0x14          /* end command     */
			|| u8(*b) >= 0x20   /* invalid command */
		)
			b = b_end;
		
		/* advance to next header command */
		b = b + 8;
	}
			
	/* failed to locate room command, or it is invalid */
	if (
		b >= b_end                   /* no room command found */
		|| b[1] != room_ct           /* invalid room count    */
		|| get16(b+2)                /* bytes 2, 3 aren't 0   */
		|| b[4] != 0x02              /* invalid ram segment   */
		|| (b[7] & 3)                /* unaligned pointer     */
		|| get24(b+5) + b[1]*8 > sz  /* pointer exceeds file  */
	)
		return 1;
	
	/* overwrite room pointers */
	memcpy(rom.raw(start + get24(b+5)), room_ptrs, room_ct * 8);
	
	/* debug output */
	//printf(" > valid header %08X\n", ofs | (rseg << 24));
	
	/* valid header */
	return 0;
}

void
scene(struct rom *rom)
{
	struct folder *list;
	struct folder *room;
	struct conf *conf;
	char *room_ptrs;
	char *scene;
	char *name;
	char *b;
	char *b_end;
	int start;
	int end;
	int sz;
	int index;
	int scard;
	int ecard;
	int unk_a;
	int unk_b;
	int rinit;
	int room_ct;
	int index_last;
	
	/* allocate space for 256 room pointers */
	room_ptrs = malloc(256 * 4 * 2);
	
	/* scenes aligned 0x1000 in retail */
	rom.align(0x1000);
	
	/* enter and parse folder */
	dir_enter("scene");
	list = list.new(0);
	if (!list.count())
		die("scene folder is empty");
	index_last = -1;
	
	/* repeats for every item in the list */
	while (list.remaining())
	{
		/* initialize variables */
		index = list.index();
		name = list.name();
		
		/* display progress */
		printf("\r""scene %d/%d: ", index, list.max());
		
		/* ensure we don't exceed table limit */
		if (index >= TBL_SCENE_ENTRIES)
			die("scene table limit exceeded");
		
		/* enter directory of list entry */
		dir_enter(name);
		
		/* parse conf */
		conf = conf.new("conf.txt", "list");
		unk_a = conf.get_int("unk-a:");
		unk_b = conf.get_int("unk-b:");
		rinit = conf.get_int("shader:");
		conf.free();
		
		/* attempt to inject file */
		scene = rom.inject("*.zscene", compress);
		start = rom.file_start();
		end = rom.file_end();
		sz = end - start;
		scard = 0;
		ecard = 0;
		
		/* if scene exists, process title card and rooms */
		if (scene)
		{
			/* title card */
			rom.inject_png(
				"title.png"
				, N64TEXCONV_IA
				, N64TEXCONV_8
				, compress
			);
			scard = rom.file_start();
			ecard = rom.file_end();
			
			/* inject rooms */
			room = room.new("*.zmap");
			if (!room.count())
				die("no rooms found");
			if (room.count() > 127)
				die("too many (%d) rooms", room.count());
			room_ct = 0;
			while (room.remaining())
			{
				/* injection failure is unacceptable */
				if (!rom.inject(room.name(), compress))
					die("'%s' injection failure", room.name());
				
				/* add to room pointer list */
				put32(room_ptrs + room_ct * 8    , rom.file_start());
				put32(room_ptrs + room_ct * 8 + 4, rom.file_end()  );
				
				/* proceed to next room */
				room_ct++;
				room.next();
			}
			room.free();
			
			/* update room pointers in first header */
			if (
			scene_header_rooms(
				rom
				, room_ptrs
				, room_ct
				, start
				, sz
				, 0x02000000
			)
			)
				die("invalid header");
			
			/* locate alternate header command (0x18) */
			b = rom.raw(start);
			b_end = b + sz;
			while (b < b_end && *b != 0x18)
			{
				/* end loop conditions */
				if (
					*b == 0x14          /* end command     */
					|| u8(*b) >= 0x20   /* invalid command */
				)
					b = b_end;
				
				/* advance to next header command */
				b = b + 8;
			}
			
			/* alternate header command found */
			if (b < b_end)
			{
				/* invalid ram segment */
				if (b[4] != 0x02)
					die("0x18 cmd: invalid ram segment %02X", b[4]);
				
				/* invalid offset */
				if (
					(b[7] & 3)              /* unaligned pointer     */
					|| get24(b+5) + 4 > sz  /* pointer exceeds file  */
				)
					die("0x18 cmd: invalid offset %08X", get32(b+4));
				
				/* grab alternate header list */
				b = rom.raw(start + get24(b+5));
				
				/* process list */
				while (b < b_end)
				{
					/* scene header failed in some way; end of list */
					if (
					scene_header_rooms(
						rom
						, room_ptrs
						, room_ct
						, start
						, sz
						, get32(b)
					)
					)
						b = b_end;
					
					/* advance to next entry */
					b = b + 4;
				}
			}
		}
		
		/* zero out any skipped entries */
		skip_test(rom, index, &index_last, TBL_SCENE, 20);
		
		/* go to table entry */
		rom.seek(TBL_SCENE + index * 20);
		
		/* write its table entry */
		rom.write32(start);  /* vrom start          */
		rom.write32(end);    /* vrom end            */
		rom.write32(scard);  /* title card start    */
		rom.write32(ecard);  /* title card end      */
		rom.write8(unk_a);   /* unknown             */
		rom.write8(rinit);   /* render init func id */
		rom.write8(unk_b);   /* unknown             */
		
		/* leave directory */
		dir_leave();
		
		/* go to next entry in list */
		list.next();
	}
	
	/* cleanup */
	free(room_ptrs);
	list.free();
	dir_leave();
	printf("success!\n");
}

void
object(struct rom *rom)
{
	struct folder *list;
	char *name;
	int index_last;
	int index;
	
	/* objects aligned 0x1000 in retail */
	rom.align(0x1000);
	
	/* enter and parse folder */
	dir_enter("object");
	list = list.new(0);
	if (!list.count())
		die("object folder is empty");
	index_last = -1;
	
	/* repeats for every item in the list */
	while (list.remaining())
	{
		/* initialize variables */
		index = list.index();
		name = list.name();
		
		/* display progress */
		printf("\r""object %d/%d: ", index, list.max());
		
		/* ensure we don't exceed table limit */
		if (index >= TBL_OBJECT_ENTRIES)
			die("object table limit exceeded");
		
		/* enter directory of list entry */
		dir_enter(name);
		
		/* attempt to inject file */
		rom.inject("*.zobj", compress);
		
		/* zero out any skipped entries */
		skip_test(rom, index, &index_last, TBL_OBJECT, 8);
		
		/* go to table entry */
		rom.seek(TBL_OBJECT + index * 8);
		
		/* write its table entry */
		/* if rom.inject() failed, file offsets return 0 */
		rom.write32(rom.file_start());
		rom.write32(rom.file_end());
		
		/* leave directory */
		dir_leave();
		
		/* go to next entry in list */
		list.next();
	}
	
	/* cleanup */
	list.free();
	dir_leave();
	printf("success!\n");
}

void
actor(struct rom *rom)
{
	struct folder *list;
	struct conf *conf;
	char *name;
	char *ovl;
	char *ss;
	int index_last;
	int index;
	int vram;
	int vram_end;
	int ivar;
	int atype;
	
	/* actors aligned 0x10 in retail */
	rom.align(0x10);
	
	/* enter and parse folder */
	dir_enter("actor");
	list = list.new(0);
	if (!list.count())
		die("actor folder is empty");
	index_last = -1;
	
	/* repeats for every item in the list */
	while (list.remaining())
	{
		/* initialize variables */
		index = list.index();
		name = list.name();
		
		/* display progress */
		printf("\r""actor %d/%d: ", index, list.max());
		
		/* ensure we don't exceed table limit */
		if (index >= TBL_ACTOR_ENTRIES)
			die("actor table limit exceeded");
		
		/* enter directory of list entry */
		dir_enter(name);
			
		/* open conf */
		conf = conf.new("conf.txt", "list");
		
		/* attempt to inject file */
		ovl = rom.inject("*.zovl", compress);
		
		/* overlay loaded successfully */
		if (ovl)
		{
			/* calculate overlay size */
			vram_end = ovl_vram_sz(ovl, rom.file_sz());
			
			/* fall back to DEAD BEEF method if no ivar in conf */
			if (!conf.exists("ivar"))
			{
				/* locate initialization variables */
				ss =
				find_bytes_stride(
					ovl
					, rom.file_sz()
					, "DEAD****************BEEF"
					, 4
					, true  /* fatal error if more than one occurrence */
				);
				
				/* failed to find any */
				if (!ss)
					die("failed to locate DEAD BEEF");
				
				/* initialization variable offset relative to overlay */
				ivar = ss - ovl;
				
				/* overwrite 0xDEAD with index */
				put16(ss, index);
				
				/* overwrite 0xBEEF with 0x0000 */
				put16(ss + 10, 0);
			}
		}
		
		/* no overlay found */
		else
		{
			vram_end = 0;
			ivar = 0;
		}
		
		/* parse conf */
		vram = conf.get_int("vram");
		atype = conf.get_int("allocation");
		if (conf.exists("ivar"))
			ivar = conf.get_int("ivar");   // ivar override
		else
			ivar = vram + ivar; // make relative to vram
		conf.free();
		
		/* make overlay size relative to vram, thus vram_end */
		vram_end = vram + vram_end;
		
		/* zero out any skipped entries */
		skip_test(rom, index, &index_last, TBL_ACTOR, 32);
		
		/* go to table entry */
		rom.seek(TBL_ACTOR + index * 32);
		
		/* write its table entry */
		/* if rom.inject() failed, file offsets return 0 */
		rom.write32(rom.file_start());  /* vrom start  */
		rom.write32(rom.file_end());    /* vrom end    */
		rom.write32(vram);              /* vram start  */
		rom.write32(vram_end);          /* vram end    */
		rom.write32(0);                 /* ram address */
		rom.write32(ivar);              /* init vars   */
		rom.write32(0);                 /* name addr   */
		rom.write16(atype);             /* alloc type  */
		
		/* leave directory */
		dir_leave();
		
		/* go to next entry in list */
		list.next();
	}
	
	/* cleanup */
	list.free();
	dir_leave();
	printf("success!\n");
}

void
particle(struct rom *rom)
{
	struct folder *list;
	struct conf *conf;
	char *name;
	char *ovl;
	char *ss;
	int index_last;
	int index;
	int vram;
	int vram_end;
	int ivar;
	int unk;
	
	/* particles aligned 0x10 in retail */
	rom.align(0x10);
	
	/* enter and parse folder */
	dir_enter("particle");
	list = list.new(0);
	if (!list.count())
		die("particle folder is empty");
	index_last = -1;
	
	/* repeats for every item in the list */
	while (list.remaining())
	{
		/* initialize variables */
		index = list.index();
		name = list.name();
		
		/* display progress */
		printf("\r""particle %d/%d: ", index, list.max());
		
		/* ensure we don't exceed table limit */
		if (index >= TBL_PARTICLE_ENTRIES)
			die("particle table limit exceeded");
		
		/* enter directory of list entry */
		dir_enter(name);
		
		/* attempt to inject file */
		ovl = rom.inject("*.zovl", compress);
		
		/* overlay loaded successfully */
		if (ovl)
		{
			/* parse conf */
			conf = conf.new("conf.txt", "list");
			vram = conf.get_int("vram");
			unk = conf.get_int("unknown");
			conf.free();
			
			/* calculate vram end */
			vram_end = vram + ovl_vram_sz(ovl, rom.file_sz());
			
			/* locate initialization variables (tuna method) */
			ss =
			find_text_stride(
				ovl
				, rom.file_sz()
				, "tuna"
				, 4
				, true  /* fatal error if more than one occurrence */
			);
			
			/* failed to find any */
			if (!ss)
				die("failed to locate 'tuna'");
			
			/* note initialization variable offset */
			ivar = vram + (ss - ovl);
			
			/* overwrite 'tuna' with index */
			put32(ss, index);
		}
		
		/* no overlay found */
		else
		{
			vram = 0;
			vram_end = 0;
			unk = 0;
			ivar = 0;
		}
		
		/* zero out any skipped entries */
		skip_test(rom, index, &index_last, TBL_PARTICLE, 28);
		
		/* go to table entry */
		rom.seek(TBL_PARTICLE + index * 28);
		
		/* write its table entry */
		/* if rom.inject() failed, file offsets return 0 */
		rom.write32(rom.file_start());  /* vrom start  */
		rom.write32(rom.file_end());    /* vrom end    */
		rom.write32(vram);              /* vram start  */
		rom.write32(vram_end);          /* vram end    */
		rom.write32(0);                 /* ram address */
		rom.write32(ivar);              /* init vars   */
		rom.write32(unk);               /* unknown     */
		
		/* leave directory */
		dir_leave();
		
		/* go to next entry in list */
		list.next();
	}
	
	/* cleanup */
	list.free();
	dir_leave();
	printf("success!\n");
}

int
main(int argc, char **argv)
{
	struct rom *rom;
	struct conf *rpl;
	char *codec;
	char *name;
	char *comp;
	int i;
	
	/* load .zzrpl */
	rpl = rpl.new("*.zzrpl", "list");
	name = rpl.get_str("baserom");
	
	/* set compression codec */
	codec = "yaz";
	
	/* load base rom */
	rom = rom.new(name);
	
	/* compressed roms are < 64 mb */
	if (rom.size() < 0x04000000)
		die("cannot inject into compressed rom, what have you done");
	
	/* dma table (dmadata) offset and number of entries */
	rom.dma(TBL_DMA, TBL_DMA_ENTRIES);
	
	/* mark files for compression */
	rom.dma_compress(DMA_ITEM_FIELD, DMA_ITEM_LOCALIZED, true);
	rom.dma_compress(DMA_CODE      , TBL_DMA_ENTRIES   , true);
	
	/* disable compression on skybox palettes (including pre-renders) */
	i = DMA_SKYBOX_FIRST + 1;
	while (i <= DMA_PRERENDER_LAST)
	{
		rom.dma_compress_one(i, false);
		i = i + 2;
	}
	
	/* mark files (and dma entries) for overwriting */
	rom.dma_queue(DMA_OVL_TITLE, DMA_OVL_MAP_MARK_DATA); /* sys ovl */
	rom.dma_queue(DMA_ACTOR_FIRST , DMA_ACTOR_LAST ); /* actors, fx */
	rom.dma_queue(DMA_OBJECT_FIRST, DMA_OBJECT_LAST); /* objects    */
	rom.dma_queue(DMA_G_PN_FIRST  , DMA_G_PN_LAST  ); /* g_pn_x     */
	rom.dma_queue(DMA_SCENE_FIRST , DMA_SCENE_LAST ); /* scenes     */
	rom.dma_queue(DMA_UNUSED_FIRST, DMA_UNUSED_LAST); /* unused     */
	rom.dma_queue(DMA_BLANK_FIRST , DMA_BLANK_LAST ); /* remainder  */
	
	/* NOTE: if none of your scenes will use prerendered *
	 *       skyboxes, mark them as well so their space  *
	 *       can be put to good use                      */
	
	/* finished initializing dma settings */
	rom.dma_ready();

	/*loadsnames*/
	g_tsv = loadfile("oot_names.tsv", 0, true/*file is optional*/);
	
	
	/* construct rom */
	systemdir(rom);
	actor(rom);
	particle(rom);
	object(rom);
	scene(rom);
	audiobank(rom);	
	audioseq(rom);
	route(rom);
	entrancecutscene(rom);
	restrictionflag(rom);
	message(rom);
	
	
	/* write built rom */
	rom.save("build.z64");
	
	/* compress rom */
	rom.compress(codec, 32);
	
	/* write compressed rom */
	rom.save(new_string("build-", codec, ".z64", 0));
	
	/* cleanup */
	rom.free();
	rpl.free();
	return 0;
}
